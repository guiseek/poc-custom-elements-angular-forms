/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ButtonType, ComponentType, InputType, Size } from "@nxc/ui/core";
export namespace Components {
    interface NxcAlert {
        "closable": boolean;
        "hide": () => Promise<boolean>;
        "open": boolean;
        "show": () => Promise<boolean>;
        "type": ComponentType;
    }
    interface NxcButton {
        "caret": boolean;
        "circle": boolean;
        "disabled": boolean;
        "loading": boolean;
        "name": string;
        "pill": boolean;
        /**
          * Removes focus from the button.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the button.
         */
        "setFocus": () => Promise<void>;
        "size": Size;
        "submit": boolean;
        "type": ButtonType;
        "value": string;
    }
    interface NxcColorPicker {
        /**
          * Set to true to disable the color picker.
         */
        "disabled": boolean;
        /**
          * The format to use for the display value. If opacity is enabled, these will translate to HEXA, RGBA, and HSLA respectively. The color picker will always accept user input in any format (including CSS color names) and convert it to the desired format.
         */
        "format": 'hex' | 'rgb' | 'hsl';
        /**
          * Set to true to render the color picker inline rather than inside a dropdown.
         */
        "inline": boolean;
        /**
          * Whether to show the opacity slider.
         */
        "opacity": boolean;
        /**
          * When `inline` is true, this determines the size of the color picker's trigger.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * An array of predefined color swatches to display. Can include any format the color picker can parse, including HEX(A), RGB(A), HSL(A), and CSS color names.
         */
        "swatches": string[];
        /**
          * By default, the value will be set in lowercase. Set this to true to set it in uppercase instead.
         */
        "uppercase": boolean;
        /**
          * The current color.
         */
        "value": string;
    }
    interface NxcDropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect": boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement": HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance": number;
        /**
          * Hides the dropdown panel
         */
        "hide": () => Promise<void>;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open": boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement": | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * Shows the dropdown panel
         */
        "show": () => Promise<void>;
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding": number;
    }
    interface NxcIcon {
        /**
          * The icon label
         */
        "label": string;
        /**
          * The icon name
         */
        "name": string;
        /**
          * The icon path
         */
        "src": string;
    }
    interface NxcIconButton {
        "disabled": boolean;
        "label": string;
        "name": string;
        "src": string;
    }
    interface NxcInput {
        "autofocus": boolean;
        "clearable": boolean;
        "disabled": boolean;
        "invalid": boolean;
        "label": string;
        "max": number;
        "maxlength": number;
        "min": number;
        "minlength": number;
        "name": string;
        "pattern": string;
        "pill": boolean;
        "placeholder": string;
        "readonly": boolean;
        /**
          * Remove o foco do elemento.
         */
        "removeFocus": () => Promise<void>;
        "required": boolean;
        /**
          * Seleciona todo texto do input.
         */
        "select": () => Promise<void>;
        /**
          * Coloca foco no elemento.
         */
        "setFocus": () => Promise<void>;
        "size": Size;
        "step": number;
        "togglePassword": boolean;
        "type": InputType;
        "valid": boolean;
        "value": string;
    }
    interface NxcMenu {
        /**
          * Removes focus from the menu.
         */
        "removeFocus": () => Promise<void>;
        /**
          * Sets focus on the menu.
         */
        "setFocus": () => Promise<void>;
        /**
          * Initiates type-to-select logic, which automatically selects an option based on what the user is currently typing. The key passed will be appended to the internal query and the selection will be updated. After a brief period, the internal query is cleared automatically. This method is intended to be used with the keydown event. Useful for enabling type-to-select when the menu doesn't have focus.
         */
        "typeToSelect": (key: string) => Promise<void>;
    }
    interface NxcMenuDivider {
    }
    interface NxcMenuItem {
        "active": boolean;
        "checked": boolean;
        "disabled": boolean;
        "value": string;
    }
    interface NxcMenuLabel {
    }
}
declare global {
    interface HTMLNxcAlertElement extends Components.NxcAlert, HTMLStencilElement {
    }
    var HTMLNxcAlertElement: {
        prototype: HTMLNxcAlertElement;
        new (): HTMLNxcAlertElement;
    };
    interface HTMLNxcButtonElement extends Components.NxcButton, HTMLStencilElement {
    }
    var HTMLNxcButtonElement: {
        prototype: HTMLNxcButtonElement;
        new (): HTMLNxcButtonElement;
    };
    interface HTMLNxcColorPickerElement extends Components.NxcColorPicker, HTMLStencilElement {
    }
    var HTMLNxcColorPickerElement: {
        prototype: HTMLNxcColorPickerElement;
        new (): HTMLNxcColorPickerElement;
    };
    interface HTMLNxcDropdownElement extends Components.NxcDropdown, HTMLStencilElement {
    }
    var HTMLNxcDropdownElement: {
        prototype: HTMLNxcDropdownElement;
        new (): HTMLNxcDropdownElement;
    };
    interface HTMLNxcIconElement extends Components.NxcIcon, HTMLStencilElement {
    }
    var HTMLNxcIconElement: {
        prototype: HTMLNxcIconElement;
        new (): HTMLNxcIconElement;
    };
    interface HTMLNxcIconButtonElement extends Components.NxcIconButton, HTMLStencilElement {
    }
    var HTMLNxcIconButtonElement: {
        prototype: HTMLNxcIconButtonElement;
        new (): HTMLNxcIconButtonElement;
    };
    interface HTMLNxcInputElement extends Components.NxcInput, HTMLStencilElement {
    }
    var HTMLNxcInputElement: {
        prototype: HTMLNxcInputElement;
        new (): HTMLNxcInputElement;
    };
    interface HTMLNxcMenuElement extends Components.NxcMenu, HTMLStencilElement {
    }
    var HTMLNxcMenuElement: {
        prototype: HTMLNxcMenuElement;
        new (): HTMLNxcMenuElement;
    };
    interface HTMLNxcMenuDividerElement extends Components.NxcMenuDivider, HTMLStencilElement {
    }
    var HTMLNxcMenuDividerElement: {
        prototype: HTMLNxcMenuDividerElement;
        new (): HTMLNxcMenuDividerElement;
    };
    interface HTMLNxcMenuItemElement extends Components.NxcMenuItem, HTMLStencilElement {
    }
    var HTMLNxcMenuItemElement: {
        prototype: HTMLNxcMenuItemElement;
        new (): HTMLNxcMenuItemElement;
    };
    interface HTMLNxcMenuLabelElement extends Components.NxcMenuLabel, HTMLStencilElement {
    }
    var HTMLNxcMenuLabelElement: {
        prototype: HTMLNxcMenuLabelElement;
        new (): HTMLNxcMenuLabelElement;
    };
    interface HTMLElementTagNameMap {
        "nxc-alert": HTMLNxcAlertElement;
        "nxc-button": HTMLNxcButtonElement;
        "nxc-color-picker": HTMLNxcColorPickerElement;
        "nxc-dropdown": HTMLNxcDropdownElement;
        "nxc-icon": HTMLNxcIconElement;
        "nxc-icon-button": HTMLNxcIconButtonElement;
        "nxc-input": HTMLNxcInputElement;
        "nxc-menu": HTMLNxcMenuElement;
        "nxc-menu-divider": HTMLNxcMenuDividerElement;
        "nxc-menu-item": HTMLNxcMenuItemElement;
        "nxc-menu-label": HTMLNxcMenuLabelElement;
    }
}
declare namespace LocalJSX {
    interface NxcAlert {
        "closable"?: boolean;
        "onNxcAfterHide"?: (event: CustomEvent<any>) => void;
        "onNxcAfterShow"?: (event: CustomEvent<any>) => void;
        "onNxcHide"?: (event: CustomEvent<any>) => void;
        "onNxcShow"?: (event: CustomEvent<any>) => void;
        "open"?: boolean;
        "type"?: ComponentType;
    }
    interface NxcButton {
        "caret"?: boolean;
        "circle"?: boolean;
        "disabled"?: boolean;
        "loading"?: boolean;
        "name"?: string;
        "onNxcBlur"?: (event: CustomEvent<any>) => void;
        "onNxcFocus"?: (event: CustomEvent<any>) => void;
        "pill"?: boolean;
        "size"?: Size;
        "submit"?: boolean;
        "type"?: ButtonType;
        "value"?: string;
    }
    interface NxcColorPicker {
        /**
          * Set to true to disable the color picker.
         */
        "disabled"?: boolean;
        /**
          * The format to use for the display value. If opacity is enabled, these will translate to HEXA, RGBA, and HSLA respectively. The color picker will always accept user input in any format (including CSS color names) and convert it to the desired format.
         */
        "format"?: 'hex' | 'rgb' | 'hsl';
        /**
          * Set to true to render the color picker inline rather than inside a dropdown.
         */
        "inline"?: boolean;
        /**
          * Emitted after the color picker closes and all transitions are complete.
         */
        "onNxcAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the color picker opens and all transitions are complete.
         */
        "onNxcAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the color picker closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onNxcHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the color picker opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onNxcShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the color picker's value changes.
         */
        "onValueChange"?: (event: CustomEvent<any>) => void;
        /**
          * Whether to show the opacity slider.
         */
        "opacity"?: boolean;
        /**
          * When `inline` is true, this determines the size of the color picker's trigger.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * An array of predefined color swatches to display. Can include any format the color picker can parse, including HEX(A), RGB(A), HSL(A), and CSS color names.
         */
        "swatches"?: string[];
        /**
          * By default, the value will be set in lowercase. Set this to true to set it in uppercase instead.
         */
        "uppercase"?: boolean;
        /**
          * The current color.
         */
        "value"?: string;
    }
    interface NxcDropdown {
        /**
          * Determines whether the dropdown should hide when a menu item is selected.
         */
        "closeOnSelect"?: boolean;
        /**
          * The dropdown will close when the user interacts outside of this element (e.g. clicking).
         */
        "containingElement"?: HTMLElement;
        /**
          * The distance in pixels from which to offset the panel away from its trigger.
         */
        "distance"?: number;
        /**
          * Emitted after the dropdown closes and all transitions are complete.
         */
        "onNxcAfterHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted after the dropdown opens and all transitions are complete.
         */
        "onNxcAfterShow"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the dropdown closes. Calling `event.preventDefault()` will prevent it from being closed.
         */
        "onNxcHide"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the dropdown opens. Calling `event.preventDefault()` will prevent it from being opened.
         */
        "onNxcShow"?: (event: CustomEvent<any>) => void;
        /**
          * Indicates whether or not the dropdown is open. You can use this in lieu of the show/hide methods.
         */
        "open"?: boolean;
        /**
          * The preferred placement of the dropdown panel. Note that the actual placement may vary as needed to keep the panel inside of the viewport.
         */
        "placement"?: | 'top'
    | 'top-start'
    | 'top-end'
    | 'bottom'
    | 'bottom-start'
    | 'bottom-end'
    | 'right'
    | 'right-start'
    | 'right-end'
    | 'left'
    | 'left-start'
    | 'left-end';
        /**
          * The distance in pixels from which to offset the panel along its trigger.
         */
        "skidding"?: number;
    }
    interface NxcIcon {
        /**
          * The icon label
         */
        "label"?: string;
        /**
          * The icon name
         */
        "name"?: string;
        /**
          * Emitted when the icon failed to load.
         */
        "onNxcError"?: (event: CustomEvent<any>) => void;
        "onNxcLoad"?: (event: CustomEvent<any>) => void;
        /**
          * The icon path
         */
        "src"?: string;
    }
    interface NxcIconButton {
        "disabled"?: boolean;
        "label"?: string;
        "name"?: string;
        "src"?: string;
    }
    interface NxcInput {
        "autofocus"?: boolean;
        "clearable"?: boolean;
        "disabled"?: boolean;
        "invalid"?: boolean;
        "label"?: string;
        "max"?: number;
        "maxlength"?: number;
        "min"?: number;
        "minlength"?: number;
        "name"?: string;
        "onBlurChange"?: (event: CustomEvent<any>) => void;
        "onFocusChange"?: (event: CustomEvent<any>) => void;
        "onValueChange"?: (event: CustomEvent<any>) => void;
        "pattern"?: string;
        "pill"?: boolean;
        "placeholder"?: string;
        "readonly"?: boolean;
        "required"?: boolean;
        "size"?: Size;
        "step"?: number;
        "togglePassword"?: boolean;
        "type"?: InputType;
        "valid"?: boolean;
        "value"?: string;
    }
    interface NxcMenu {
        /**
          * Emitted when the menu loses focus.
         */
        "onNxcBlur"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the menu gains focus.
         */
        "onNxcFocus"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when a menu item is selected.
         */
        "onNxcSelect"?: (event: CustomEvent<any>) => void;
    }
    interface NxcMenuDivider {
    }
    interface NxcMenuItem {
        "active"?: boolean;
        "checked"?: boolean;
        "disabled"?: boolean;
        "value"?: string;
    }
    interface NxcMenuLabel {
    }
    interface IntrinsicElements {
        "nxc-alert": NxcAlert;
        "nxc-button": NxcButton;
        "nxc-color-picker": NxcColorPicker;
        "nxc-dropdown": NxcDropdown;
        "nxc-icon": NxcIcon;
        "nxc-icon-button": NxcIconButton;
        "nxc-input": NxcInput;
        "nxc-menu": NxcMenu;
        "nxc-menu-divider": NxcMenuDivider;
        "nxc-menu-item": NxcMenuItem;
        "nxc-menu-label": NxcMenuLabel;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "nxc-alert": LocalJSX.NxcAlert & JSXBase.HTMLAttributes<HTMLNxcAlertElement>;
            "nxc-button": LocalJSX.NxcButton & JSXBase.HTMLAttributes<HTMLNxcButtonElement>;
            "nxc-color-picker": LocalJSX.NxcColorPicker & JSXBase.HTMLAttributes<HTMLNxcColorPickerElement>;
            "nxc-dropdown": LocalJSX.NxcDropdown & JSXBase.HTMLAttributes<HTMLNxcDropdownElement>;
            "nxc-icon": LocalJSX.NxcIcon & JSXBase.HTMLAttributes<HTMLNxcIconElement>;
            "nxc-icon-button": LocalJSX.NxcIconButton & JSXBase.HTMLAttributes<HTMLNxcIconButtonElement>;
            "nxc-input": LocalJSX.NxcInput & JSXBase.HTMLAttributes<HTMLNxcInputElement>;
            "nxc-menu": LocalJSX.NxcMenu & JSXBase.HTMLAttributes<HTMLNxcMenuElement>;
            "nxc-menu-divider": LocalJSX.NxcMenuDivider & JSXBase.HTMLAttributes<HTMLNxcMenuDividerElement>;
            "nxc-menu-item": LocalJSX.NxcMenuItem & JSXBase.HTMLAttributes<HTMLNxcMenuItemElement>;
            "nxc-menu-label": LocalJSX.NxcMenuLabel & JSXBase.HTMLAttributes<HTMLNxcMenuLabelElement>;
        }
    }
}
